from typing import Dict, List, Optional, Tuple
from django.utils import timezone
from django.conf import settings
import logging

from .base_agent import BaseAgent, MessageContext, AgentResponse


logger = logging.getLogger(__name__)


class AgentManager:
    """
    Gestor centralizado de agentes de chat
    """

    def __init__(self):
        self.agents: List[BaseAgent] = []
        self.fallback_agent: Optional[BaseAgent] = None
        self.is_initialized = False

    def register_agent(self, agent: BaseAgent) -> bool:
        """
        Registra un nuevo agente

        Args:
            agent: Instancia del agente a registrar

        Returns:
            True si fue registrado exitosamente
        """
        try:
            # Verificar que no exista un agente con el mismo nombre
            if any(a.name == agent.name for a in self.agents):
                logger.warning(f"Agent with name '{agent.name}' already exists")
                return False

            self.agents.append(agent)
            # Ordenar por prioridad (mayor prioridad primero)
            self.agents.sort(key=lambda a: a.priority, reverse=True)

            logger.info(f"Agent '{agent.name}' registered with priority {agent.priority}")
            return True

        except Exception as e:
            logger.error(f"Error registering agent '{agent.name}': {e}")
            return False

    def unregister_agent(self, agent_name: str) -> bool:
        """
        Desregistra un agente por nombre

        Args:
            agent_name: Nombre del agente a desregistrar

        Returns:
            True si fue desregistrado exitosamente
        """
        try:
            initial_count = len(self.agents)
            self.agents = [a for a in self.agents if a.name != agent_name]

            if len(self.agents) < initial_count:
                logger.info(f"Agent '{agent_name}' unregistered")
                return True
            else:
                logger.warning(f"Agent '{agent_name}' not found")
                return False

        except Exception as e:
            logger.error(f"Error unregistering agent '{agent_name}': {e}")
            return False

    def set_fallback_agent(self, agent: BaseAgent):
        """
        Establece un agente de respaldo para cuando ningún otro puede manejar el mensaje

        Args:
            agent: Agente de respaldo
        """
        self.fallback_agent = agent
        logger.info(f"Fallback agent set to '{agent.name}'")

    def get_response(self, context: MessageContext) -> Optional[AgentResponse]:
        """
        Obtiene respuesta de los agentes para un mensaje

        Args:
            context: Contexto del mensaje

        Returns:
            AgentResponse del mejor agente o None
        """
        try:
            best_agent = None
            best_response = None
            best_confidence = 0.0

            # Buscar el mejor agente para manejar el mensaje
            for agent in self.agents:
                if not agent.is_active:
                    continue

                if agent.can_handle(context):
                    # Pre-procesar el mensaje
                    processed_context = agent.pre_process_message(context)

                    # Generar respuesta
                    response = agent.generate_response(processed_context)

                    if response and agent.validate_response(response):
                        # Post-procesar la respuesta
                        response = agent.post_process_response(response, processed_context)

                        # Verificar si es mejor que la respuesta actual
                        if response.confidence > best_confidence:
                            best_agent = agent
                            best_response = response
                            best_confidence = response.confidence

                        # Si la confianza es muy alta, usar esta respuesta directamente
                        if response.confidence >= 0.9:
                            break

            # Si encontramos una respuesta con confianza suficiente, usarla
            if best_response and best_confidence >= best_agent.confidence_threshold:
                logger.info(f"Response generated by '{best_agent.name}' with confidence {best_confidence:.2f}")
                return best_response

            # Si no encontramos respuesta adecuada, usar agente de respaldo
            if self.fallback_agent and self.fallback_agent.is_active:
                if self.fallback_agent.can_handle(context):
                    processed_context = self.fallback_agent.pre_process_message(context)
                    fallback_response = self.fallback_agent.generate_response(processed_context)

                    if fallback_response and self.fallback_agent.validate_response(fallback_response):
                        fallback_response = self.fallback_agent.post_process_response(
                            fallback_response, processed_context
                        )
                        logger.info(f"Fallback response generated by '{self.fallback_agent.name}'")
                        return fallback_response

            logger.info("No suitable agent found for message")
            return None

        except Exception as e:
            logger.error(f"Error getting response from agents: {e}")
            return None

    def get_agent_candidates(self, context: MessageContext) -> List[Tuple[BaseAgent, float]]:
        """
        Obtiene lista de agentes que pueden manejar el mensaje con sus scores de confianza

        Args:
            context: Contexto del mensaje

        Returns:
            Lista de tuplas (agente, confianza) ordenada por confianza descendente
        """
        candidates = []

        for agent in self.agents:
            if not agent.is_active:
                continue

            if agent.can_handle(context):
                confidence = agent.get_confidence_score(context)
                candidates.append((agent, confidence))

        # Ordenar por confianza descendente
        candidates.sort(key=lambda x: x[1], reverse=True)
        return candidates

    def get_active_agents(self) -> List[BaseAgent]:
        """
        Obtiene lista de agentes activos

        Returns:
            Lista de agentes activos ordenados por prioridad
        """
        return [agent for agent in self.agents if agent.is_active]

    def get_agent_by_name(self, name: str) -> Optional[BaseAgent]:
        """
        Obtiene un agente por nombre

        Args:
            name: Nombre del agente

        Returns:
            Instancia del agente o None si no existe
        """
        for agent in self.agents:
            if agent.name == name:
                return agent
        return None

    def enable_agent(self, name: str) -> bool:
        """
        Activa un agente por nombre

        Args:
            name: Nombre del agente

        Returns:
            True si fue activado exitosamente
        """
        agent = self.get_agent_by_name(name)
        if agent:
            agent.enable()
            logger.info(f"Agent '{name}' enabled")
            return True
        return False

    def disable_agent(self, name: str) -> bool:
        """
        Desactiva un agente por nombre

        Args:
            name: Nombre del agente

        Returns:
            True si fue desactivado exitosamente
        """
        agent = self.get_agent_by_name(name)
        if agent:
            agent.disable()
            logger.info(f"Agent '{name}' disabled")
            return True
        return False

    def get_manager_stats(self) -> Dict:
        """
        Obtiene estadísticas del gestor de agentes

        Returns:
            Dict con estadísticas
        """
        active_agents = self.get_active_agents()

        return {
            'total_agents': len(self.agents),
            'active_agents': len(active_agents),
            'inactive_agents': len(self.agents) - len(active_agents),
            'has_fallback': self.fallback_agent is not None,
            'fallback_active': self.fallback_agent.is_active if self.fallback_agent else False,
            'agents_by_priority': [
                {
                    'name': agent.name,
                    'priority': agent.priority,
                    'active': agent.is_active,
                    'type': agent.__class__.__name__
                }
                for agent in self.agents
            ]
        }

    def test_response(self, message_content: str, company_info: Dict = None,
                     sender_info: Dict = None) -> Dict:
        """
        Prueba qué respuesta se generaría para un mensaje dado

        Args:
            message_content: Contenido del mensaje a probar
            company_info: Información de la empresa (opcional)
            sender_info: Información del remitente (opcional)

        Returns:
            Dict con información de la prueba
        """
        # Crear contexto de prueba
        context = MessageContext(
            message_content=message_content,
            sender_id="test_sender",
            conversation_id="test_conversation",
            company_id="test_company",
            company_info=company_info or {'name': 'Empresa de Prueba'},
            sender_info=sender_info or {'name': 'Usuario de Prueba'}
        )

        # Obtener candidatos
        candidates = self.get_agent_candidates(context)

        # Obtener mejor respuesta
        response = self.get_response(context)

        return {
            'message': message_content,
            'response': response.message if response else None,
            'selected_agent': response.agent_name if response else None,
            'confidence': response.confidence if response else 0.0,
            'candidates': [
                {
                    'agent_name': agent.name,
                    'confidence': confidence,
                    'priority': agent.priority
                }
                for agent, confidence in candidates
            ],
            'total_candidates': len(candidates),
            'fallback_used': (
                response and
                self.fallback_agent and
                response.agent_name == self.fallback_agent.name
            ) if response else False
        }

    def initialize_default_agents(self):
        """
        Inicializa los agentes por defecto del sistema
        """
        if self.is_initialized:
            return

        from .fiscko_agents import create_fiscko_agents

        # Cargar agentes específicos de Fizko
        fiscko_agents = create_fiscko_agents()
        for agent in fiscko_agents:
            self.register_agent(agent)

        self.is_initialized = True
        logger.info("Default agents initialized")


# Instancia global del gestor de agentes
agent_manager = AgentManager()